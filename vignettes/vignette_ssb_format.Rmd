---
title: "Uttrekk fra Dynarev til R"
author: "Martin Skjæveland"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ssb_format}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Klassen ssb_format tilbyr mapping av enten numeriske eller kategoriske
variabler i henhold til en forhåndsdefinert JSON-fil eller liste.
Klassen etterligner noe funskjonalitet fra SAS og klassen SsbFormat fra
Python-biblioteket ssb-fagfunksjoner.

### Hvorfor bruke denne klassen?

I statistikk brukes en rekke ulike kodelister, og det er behov for å få
korrespondanse mellom dem, f.eks. ved aggregering eller ved omkoding fra
datakilde til koder i Statistikkbanken. Det er også behov for å enkelt
kunne mappe numeriske verdier til kategoriske variabler. JSON-filer er
godt egnet for å lagre denne typen mapping mellom en kodelister samt
mellom intervaller og kategorier. Denne klassen gjør det enkelt å bruke
applisere mappingen fra JSON-filene på data.

Denne klassen og SsbFormat fra Python takler JSON-filer i samme format,
noe som gjør formatene gjenbrukbare. Dermed er det mulig å bytte mellom
språk uten å måtte skrive formatene på nytt.

Mapping-metodene fra ssb_format er dessuten mer effektive enn det
R-funksjonene ifelse og dplyr::case_when er.

### Noen viktige forskjeller fra SsbFormat og SAS

Klassen fungerer likt som Python-ekvivalenten SsbFormat i den forstand
at den kan lese inn et JSON-lignende objekt og bruke dette til å mappe
numeriske verdier til kategorier basert på dette. I tillegg er det lagt
opp til at R-klassen å kategori-til-kategori-mapping for å kompensere
for Python-funksjonen
[map](https://docs.python.org/3/library/functions.html#map){.uri}.

Ingen av disse klassene tilbyr noen løsning på overlappende intervaller
slik som i SAS.

#### OBS: Potensiell felle som burde løses

En viktig forskjell er at det kun er de nedre verdiene i intervallene
som bestemmer kategoriseringen, med unntak av den øverste grenseverdien.
Dermed kan det gi rare resultater ved bruk av
ssb_format\$map_values_range() hvor dette er formatet:

``` json
{
  "0-9": "1", 
  "10-20": "2", 
  "22-30": "3", 
  "other": "4" 
}
```

21 vil bli "2" fordi den neste nedre grenseverdien etter 10 er 22. 31
vil imidlertid gi "4" fordi den øverste grenseverdien er 30.

Python-klassen SsbFormat fungerer ikke med desimaltall. Det gjør
ssb_format. Det virker imidlertid annerledes fra formater i SAS, hvor
den øvre grensverdien i et intervall gjerne angis som 9,9999 dersom vi
ønsker at 9,5 skal falle under "1". Ved bruk av SsbFormat er det
nødvendig å runde ned til nærmeste heltall først. I ssb_format vil ikke
øvre grenseverdi ha noen betydning, og 9,5 vil falle under "1" fordi 9
\< neste nedre grenseverdi (10).
